// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    function signedIn() { return request.auth != null; }

    // ----- LISTINGS -----
    match /listings/{id} {
      // Public read so the client can resolve sellerID
      allow read: if true;
      // Your existing create/update/delete logic stays as you had it
      allow create: if signedIn()
        && request.resource.data.sellerID == request.auth.uid
        && request.resource.data.price is number
        && request.resource.data.price >= 0
        && (request.resource.data.status in ['active','pending'])
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      allow update: if signedIn()
        && (resource.data.sellerID == request.auth.uid)
        && request.resource.data.sellerID == resource.data.sellerID
        && ((('price' in request.resource.data) ? (request.resource.data.price is number && request.resource.data.price >= 0) : true))
        && ((('status' in request.resource.data) ? (request.resource.data.status in ['active','pending','sold','removed']) : true))
        && (request.resource.data.updatedAt is timestamp);

      allow delete: if signedIn()
        && (resource.data.sellerID == request.auth.uid);
    }

    // Support capitalized Listings if some docs live there
    match /Listings/{id} {
      allow read: if true;
    }

    // ----- ROLES -----  (unchanged)
    match /roles/{uid} {
      allow read: if signedIn() && uid == request.auth.uid;
      allow write: if false;
    }

    // ----- USERS / WISHLIST -----  (unchanged)
    match /users/{uid} {
      match /saved/{listingId} {
        allow read, write: if signedIn() && request.auth.uid == uid;
      }
    }

    // ----- CHATS ---- 
    match /chats/{chatId} {
      // Allow GET on missing docs so client can check existence before creating
      allow get: if request.auth != null &&
        (
          !exists(/databases/$(db)/documents/chats/$(chatId)) ||
          (resource.data.participants is list && request.auth.uid in resource.data.participants)
        );

      // Disallow listing all chats
      allow list: if request.auth != null;

      // Create: signed-in, exactly two participants incl. creator, must include listingId
      // Keep minimal type checks to avoid serverTimestamp() issues
      allow create: if request.auth != null
        && (request.resource.data.participants is list)
        && (request.resource.data.participants.size() == 2)
        && (request.auth.uid in request.resource.data.participants)
        && (request.resource.data.listingId is string);

      // Update/Delete: only participants of this chat
      allow read, update, delete: if request.auth != null
        && (resource.data.participants is list)
        && (request.auth.uid in resource.data.participants);

      // Messages subcollection
      match /messages/{msgId} {
      // Only participants can read
      allow read: if request.auth != null
        && (request.auth.uid in get(/databases/$(db)/documents/chats/$(chatId)).data.participants);

      // Only participants can create; senderId must match; basic shape checks
      allow create: if request.auth != null
        && (request.auth.uid in get(/databases/$(db)/documents/chats/$(chatId)).data.participants)
        && (request.resource.data.senderId == request.auth.uid)
        && (request.resource.data.text is string && request.resource.data.text.size() > 0)
        && (request.resource.data.sentAt is timestamp);
      }
    }  
  }
}